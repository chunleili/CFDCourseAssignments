###命名规则
采用骆驼命名法
####变量名,函数名:
 均小写, 不同单词的首字母大写, 第一个字母小写, 如:
localTimeStepping(), 表示当地时间步法
calMa()表示计算并返回马赫数
caseNo 表示不同的初场方案号

例外情况:约定俗称的物理量名字, 如:
dt表示时间步长
T表示静温

####类型名
与变量名命名法唯一的区别在于首字母大写, 如
Tensor表示张量场
Field表示向量场

####常量名
全大写, 不同单词连接用下划线_
例外:maxI和maxJ



###函数调用关系, 算法大致框架
main（）函数是入口。伪代码如下：

```c++
genMesh();\\创建网格,备份到mesh.txt中，内容为节点坐标，nodes[I][J], 还要输出center[I][J]
\\网格分为3个block，入口区entrance,收缩区conver, 出口区exitWay
init();\\设置初场
for(t=0;t<stop;t+=dt)
{
    dt=localTimeStepping();\\当地时间步法，注意取全域最大当地时间步
    solve();\\求解
}
print();\\打印
```



而solve（）又分为3阶荣格库塔法

```c++
for(I=0;I<=maxI;I++)
{
	 Q0[k] = Q[I][J][k];\\先保存原始流场变量, k=从1到3

	spaceDis(Q[I][J], dt, R[I][J], I);\\再进行空间离散
    BCs();\\更新一下边界条件
	Q[I][J][k] = Q0[k] - alpha1 * dt / dx * R[I][J][k];\\ k=从1到3

	\\上面两行重复3遍，alpha换成alpaha1,2,3
     
}
```

其中空间离散spaceDis()包括

```c++
conv();\\求出当地对流通量F[I+1/2][J]等四个F
 R=。。。\\解出向量R[I][J]，为当地残差

```



每个conv（）都是Roe格式的对流项离散

```c++
Roe格式的一堆代码。。。
返回F的引用
```

此外，边界条件为0法向梯度，采用虚拟网格。

```c++
for J:
    Q[maxI][J]=Q[maxI-1][J];
Q[maxI][0]=Q[maxI-1][1];
。。。共4个
```

###详细算法

####