采用函数式编程。

main（）函数是入口。伪代码如下：

```c++
genMesh();\\创建网格,备份到mesh.txt中，内容为节点坐标，nodes[I][J], 还要输出center[I][J]
\\网格分为3个block，入口区entrance,收缩区conver, 出口区exitWay
init();\\设置初场
for(t=0;t<stop;t+=dt)
{
    dt=localTimeStepping();\\当地时间步法，注意取全域最大当地时间步
    solve();\\求解
}
print();\\打印
```



而solve（）又分为3阶荣格库塔法

```c++
for(I=0;I<=maxI;I++)
{
	 Q0[k] = Q[I][J][k];\\先保存原始流场变量, k=从1到3

	spaceDis(Q[I][J], dt, R[I][J], I);\\再进行空间离散
    BCs();\\更新一下边界条件
	Q[I][J][k] = Q0[k] - alpha1 * dt / dx * R[I][J][k];\\ k=从1到3

	\\上面两行重复3遍，alpha换成alpaha1,2,3
     
}
```

其中空间离散spaceDis()包括

```c++
conv();\\求出当地对流通量F[I+1/2][J]等四个F
 R=。。。\\解出向量R[I][J]，为当地残差

```



每个conv（）都是Roe格式的对流项离散

```c++
Roe格式的一堆代码。。。
返回F的引用
```

此外，边界条件为0法向梯度，采用虚拟网格。

```c++
for J:
    Q[maxI][J]=Q[maxI-1][J];
Q[maxI][0]=Q[maxI-1][1];
。。。共4个
```

